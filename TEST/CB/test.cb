// -- IMPORTS

require "ecr"
require "http/server";

// -- MODULES

module TEST
{
    // -- TYPES

    abstract struct ABSTRACT
    {
    }

    // ~~

    struct POSITION
    {
        // -- CONSTRUCTORS

        def Initialize(
            ^X : INT32,
            ^Y : INT32,
            ^Z : INT32
            )
        {
        }
    }

    // ~~

    enum COLOR
    {
        // -- CONSTANTS

        #Red
        #Green
        #Blue

        // -- INQUIRIES

        def IsRed?(
            )
        {
            return self == #Red;
        }
    }

    // ~~

    struct POINT
    {
        // -- CONSTRUCTORS

        def Initialize(
            ^Name : STRING,
            ^Position : POSITION,
            ^Color : COLOR
            )
        {
        }

        // -- INQUIRIES

        def IsBlue(
            )
        {
            return ^Color == COLOR::#Blue;
        }
    }

    // ~~

    struct PERSON
    {
        // -- ATTRIBUTES

        property Name, Age, Color;

        // -- CONSTRUCTORS

        def Initialize(
            ^Name : STRING,
            ^Age : INT32,
            ^Color : COLOR
            )
        {
        }

        // -- INQUIRIES

        def IsGreen?(
            )
        {
            return Color == COLOR::#Green;
        }

        // -- OPERATIONS

        protected def Print(
            )
        {
            Puts( "#{age} - #{name}" );
        }
    }

    // ~~

    class TEST
    {
        // -- CONSTRUCTORS

        def Initialize(
            ^Hello : STRING,
            ^World : STRING
            )
        {
        }

        // -- OPERATIONS

        def TestIf(
            count : INT
            ) : INT
        {
            if ( count <= 1 )
            {
                return 10;
            }

            if ( count <= 1 )
            {
                return 10;
            }
            else
            {
                return 20;
            }

            if ( count <= 1 )
            {
                return 10;
            }
            elsif ( count <= 2 )
            {
                return 20;
            }
            else
            {
                return 30;
            }
        }

        // ~~

        def TestUnless(
            count : INT
            ) : INT
        {
            unless ( count > 1 )
            {
                return 10;
            }

            unless ( count > 1 )
            {
                return 10;
            }
            else
            {
                return 20;
            }
        }

        // ~~

        def TestWhile(
            count : INT
            )
        {
            index = 0;

            while ( index < count )
            {
                index = index + 1;
            }
        }

        // ~~

        def TestUntil(
            count : INT
            )
        {
            index = 0;

            until ( index >= count )
            {
                index = index + 1;
            }
        }

        // ~~

        def TestCase(
            count : INT
            )
        {
            case ( count )
            {
                when 1
                {
                    return 10;
                }
            }

            case ( count )
            {
                when 1
                {
                    return 10;
                }
                when 2
                {
                    return 20;
                }
            }

            case ( count )
            {
                when 1
                {
                    return 10;
                }
                when 2
                {
                    return 20;
                }
                else
                {
                    return 30;
                }
            }
        }

        // ~~

        def TestBegin(
            )
        {
            begin
            {
                result = 1;
            }
            rescue
            {
                result = 2;
            }
            else
            {
                result = 3;
            }
            ensure
            {
                result = 4;
            }
        }

        // ~~

        def TestRescue(
            )
        {
            result = 1;
        }
        rescue
        {
            result = 2;
        }
        else
        {
            result = 3;
        }
        ensure
        {
            result = 4;
        }

        // ~~

        def TestEach(
            )
        {
            "0123456789".EachChar
                do | character |
                {
                    Print( character );
                }

            Print( '\n' );

            [
                {1, "A"},
                {2, "B"}
            ].Each
                do | key, value |
                {
                    Puts( "#{key} : #{value}" );
                }
        }

        // ~~

        def TestType(
            )
        {
            data = ARRAY( NAMED_TUPLE( Id: INT32, Message: STRING ) ).New
        }

        // ~~

        def TestInterpolation(
            )
        {
            Puts( "Test #{^Hello + " Test #{^Hello} #{^World} Test " + ^World} Test" );
            Puts( %(Test #{^Hello + %( Test #{^Hello} #{^World} Test ) + ^World} Test) );
            Puts( %[Test #{^Hello + %[ Test #{^Hello} #{^World} Test ] + ^World} Test] );
            Puts( %{Test #{^Hello + %{ Test #{^Hello} #{^World} Test } + ^World} Test} );
            Puts( %<Test #{^Hello + %< Test #{^Hello} #{^World} Test > + ^World} Test> );
            Puts( %|Test #{^Hello + %| Test #{^Hello} #{^World} Test | + ^World} Test| );
            Puts( %(Test #{^Hello + %[ Test #{^Hello} #{^World} Test ] + ^World} Test) );
            Puts( %Q(Test #{^Hello + %Q( Test #{^Hello} #{^World} Test ) + ^World} Test) );
            Puts( %Q[Test #{^Hello + %Q[ Test #{^Hello} #{^World} Test ] + ^World} Test] );
            Puts( %Q{Test #{^Hello + %Q{ Test #{^Hello} #{^World} Test } + ^World} Test} );
            Puts( %Q<Test #{^Hello + %Q< Test #{^Hello} #{^World} Test > + ^World} Test> );
            Puts( %Q|Test #{^Hello + %Q| Test #{^Hello} #{^World} Test | + ^World} Test| );
            Puts( %Q(Test #{^Hello + %Q[ Test #{^Hello} #{^World} Test ] + ^World} Test) );

            Puts( "Test \#{^Hello + \" Test \#{^Hello} \#{^World} Test \" + ^World} Test" );
            Puts( %q(Test #{^Hello + %q( Test #{^Hello} #{^World} Test ) + ^World} Test) );
            Puts( %q[Test #{^Hello + %q[ Test #{^Hello} #{^World} Test ] + ^World} Test] );
            Puts( %q{Test #{^Hello + %q{ Test #{^Hello} #{^World} Test } + ^World} Test} );
            Puts( %q<Test #{^Hello + %q< Test #{^Hello} #{^World} Test > + ^World} Test> );
            Puts( %q(Test #{^Hello + %q[ Test #{^Hello} #{^World} Test ] + ^World} Test) );
        }

        // ~~

        def TestServer(
            )
        {
            server = HTTP::SERVER.New
                do | context |
                {
                    context.Response.ContentType = "text/plain";
                    context.Response.Print( "Hello world! The time is #{TIME.Now}" );
                }

            address = server.BindTcp( 8080 );
            Puts( "Listening on http://#{address}" );
            server.Listen();
        }
    }

    // -- STATEMENTS

    test = TEST.New( "Hello", "World" );
    test.TestInterpolation();

    // ~~

    person_array = ARRAY( PERSON ).New();
    person_array.Push( PERSON.New( "Red", 1, COLOR::#Red ) );
    person_array.Push( PERSON.New( "Green", 2, COLOR::#Green ) );
    person_array.Push( PERSON.New( "Blue", 2, COLOR::#Blue ) );

    // ~~

    server = HTTP::SERVER.New
        do | context |
        {
            response = context.Response;
            request = context.Request;

            response.Headers[ "Server" ] = "Crystal";
            response.Headers[ "Date" ] = HTTP.FormatTime( TIME.Now );

            case ( request.Path )
            {
                when "/"
                {
                    response.StatusCode = 200;
                    response.Headers[ "Content-Type" ] = "text/html; charset=UTF-8";
                    ECR.Embed "test.ecr", response
                }
                when "/time"
                {
                    response.Headers[ "Content-Type" ] = "text/html; charset=UTF-8";
                    context.Response.Print( "The time is #{TIME.Now}<br/><a href=\"/\">Back</a>" );
                }
                else
                {
                    response.StatusCode = 404;
                }
            }
        }

    Puts( "Listening on http://127.0.0.1:8080" );

    server.Listen( "127.0.0.1", 8080, reuse_port: true )
}
